<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend AppName="Morning" Platform="DotNet">
  <OutputDir KeepHistoric="True" KeepXmlFiles="True">C:\Users\bfoster\Dropbox\DEV\Morning\Morning\NDependOut</OutputDir>
  <Assemblies>
    <Name>View</Name>
    <Name>ViewModel</Name>
    <Name>Model</Name>
    <Name>BaseInterfaceLibrary</Name>
    <Name>Services</Name>
    <Name>Messenger</Name>
    <Name>ServiceTests</Name>
    <Name>Factory</Name>
    <Name>FactoryTest</Name>
    <Name>WindowNavigator</Name>
    <Name>DependencyInjector</Name>
    <Name>Launcher</Name>
  </Assemblies>
  <FrameworkAssemblies>
    <Name>mscorlib</Name>
    <Name>PresentationFramework</Name>
    <Name>System.Xaml</Name>
    <Name>System</Name>
    <Name>PresentationCore</Name>
    <Name>Ninject</Name>
    <Name>System.Core</Name>
    <Name>System.Web.Services</Name>
    <Name>System.Xml</Name>
    <Name>Microsoft.VisualStudio.QualityTools.UnitTestFramework</Name>
  </FrameworkAssemblies>
  <Dirs>
    <Dir>C:\windows\Microsoft.NET\Framework\v4.0.30319</Dir>
    <Dir>C:\windows\Microsoft.NET\Framework\v4.0.30319\WPF</Dir>
    <Dir>C:\Users\bfoster\Dropbox\DEV\Morning\Morning\Morning\bin\Debug</Dir>
    <Dir>C:\Users\bfoster\Dropbox\DEV\Morning\Morning\ServiceTests\bin\Debug</Dir>
    <Dir>C:\Users\bfoster\Dropbox\DEV\Morning\Morning\FactoryTest\bin\Debug</Dir>
    <Dir>C:\Users\bfoster\Dropbox\DEV\Morning\Morning\WindowNavigator\bin\Debug</Dir>
    <Dir>C:\Users\bfoster\Dropbox\DEV\Morning\Morning\Launcher\bin\Debug</Dir>
  </Dirs>
  <Report Kind="0" SectionsEnabled="12287" XslPath="" Flags="64512">
    <Section Enabled="True">Application Metrics</Section>
    <Section Enabled="True">.NET Assemblies Metrics</Section>
    <Section Enabled="True">Treemap Metric View</Section>
    <Section Enabled="True">.NET Assemblies Abstractness vs. Instability</Section>
    <Section Enabled="True">.NET Assemblies Dependencies</Section>
    <Section Enabled="True">.NET Assemblies Dependency Graph</Section>
    <Section Enabled="True">.NET Assemblies Build Order</Section>
    <Section Enabled="True">Analysis Log</Section>
    <Section Enabled="True">CQL Rules Violated</Section>
    <Section Enabled="True">Types Metrics</Section>
    <Section Enabled="False">Types Dependencies</Section>
  </Report>
  <BuildComparisonSetting ProjectMode="DontCompare" BuildMode="MostRecentBuildAvailable" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="1" />
  <BaselineInUISetting ProjectMode="DontCompare" BuildMode="MostRecentBuildAvailable" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="1" />
  <CoverageFiles UncoverableAttribute="" />
  <SourceFileRebasing FromPath="" ToPath="" />
  <Queries>
    <Group Name="Code Quality" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Methods too complex - critical (ILCyclomaticComplexity)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  ILCyclomaticComplexity > 40 AND 
  ILNestingDepth > 4 
  ORDER BY ILCyclomaticComplexity DESC

// METHODS WHERE ILCyclomaticComplexity > 40 
// are really too complex and should be split 
// in smaller methods, or even types.
// (except if they are automatically generated by a tool).
// See the definition of the ILCyclomaticComplexity metric here 
// http://www.ndepend.com/Metrics.aspx#ILCC
// See the definition of the ILNestingDepth metric here 
// http://www.NDepend.com/Metrics.aspx#ILNestingDepth]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Methods with too many parameters - critical (NbParameters)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  NbParameters > 8
  ORDER BY NbParameters DESC

// METHODS WHERE NbParameters > 8 might be painful to call 
// and might degrade performance. You should prefer using 
// additional properties/fields to the declaring type to 
// handle numerous states. Another alternative is to provide 
// a class or structure dedicated to handle arguments passing 
// (for example see the class System.Diagnostics.ProcessStartInfo 
// and the method System.Diagnostics.Process.Start(ProcessStartInfo))
// See the definition of the NbParameters metric here 
// http://www.ndepend.com/Metrics.aspx#NbParameters
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Quick summary of methods to refactor</Name>
WARN IF Count > 0 IN SELECT 
   METHODS /*OUT OF "YourGeneratedCode" */ WHERE 

                                    // Metrics' definitions
  ( NbLinesOfCode > 30 OR           // http://www.ndepend.com/Metrics.aspx#NbLinesOfCode
    NbILInstructions > 200 OR       // http://www.ndepend.com/Metrics.aspx#NbILInstructions
    CyclomaticComplexity > 20 OR    // http://www.ndepend.com/Metrics.aspx#CC
    ILCyclomaticComplexity > 50 OR  // http://www.ndepend.com/Metrics.aspx#ILCC
    ILNestingDepth > 4 OR           // http://www.ndepend.com/Metrics.aspx#ILNestingDepth
    NbParameters > 5 OR             // http://www.ndepend.com/Metrics.aspx#NbParameters
    NbVariables > 8 OR              // http://www.ndepend.com/Metrics.aspx#NbVariables
    NbOverloads > 6 )               // http://www.ndepend.com/Metrics.aspx#NbOverloads
     AND 

  // Here are some ways to avoid taking account of generated methods.
  !( NameIs "InitializeComponent()" OR
     // NDepend.CQL.GeneratedAttribute is defined in 
     // the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
     // You can define your own attribute to mark "Generated".
     HasAttribute "OPTIONAL:NDepend.CQL.GeneratedAttribute") ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods too big (NbLinesOfCode)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
   NbLinesOfCode > 30 
   ORDER BY NbLinesOfCode DESC

// METHODS WHERE NbLinesOfCode > 30 are extremely complex 
// and should be split in smaller methods 
// (except if they are automatically generated by a tool).
// See the definition of the NbLinesOfCode metric here 
// http://www.ndepend.com/Metrics.aspx#NbLinesOfCode]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods too big (NbILInstructions)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  NbILInstructions > 200 
  ORDER BY NbILInstructions DESC

// METHODS WHERE NbILInstructions > 200 are extremely complex 
// and should be split in smaller methods 
// (except if they are automatically generated by a tool).
// See the definition of the NbILInstructions metric here 
// http://www.ndepend.com/Metrics.aspx#NbILInstructions]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods too complex (CyclomaticComplexity)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  CyclomaticComplexity > 20 
  ORDER BY CyclomaticComplexity DESC

// METHODS WHERE CyclomaticComplexity > 15 are hard to understand and maintain.
// METHODS WHERE CyclomaticComplexity > 30 are extremely complex 
// and should be split in smaller methods 
// (except if they are automatically generated by a tool).
// See the definition of the CyclomaticComplexity metric here 
// http://www.ndepend.com/Metrics.aspx#CC]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods too complex (ILCyclomaticComplexity)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  ILCyclomaticComplexity > 40 
  ORDER BY ILCyclomaticComplexity DESC

// METHODS WHERE ILCyclomaticComplexity > 20 
// are hard to understand and maintain.
// METHODS WHERE ILCyclomaticComplexity > 40 
// are extremely complex and should be split 
// in smaller methods 
// (except if they are automatically generated by a tool).
// See the definition of the ILCyclomaticComplexity metric here 
// http://www.ndepend.com/Metrics.aspx#ILCC]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods too complex (ILNestingDepth)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  ILNestingDepth > 4 
  ORDER BY ILNestingDepth DESC

// METHODS WHERE ILNestingDepth > 4 are hard 
// to understand and maintain. 
// METHODS WHERE ILNestingDepth > 8 is higher 
// than 8 are extremely complex 
// and should be split in smaller methods 
// (except if they are automatically generated by a tool). 
// See the definition of the NbILInstructions metric here 
// http://www.NDepend.com/Metrics.aspx#ILNestingDepth]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods poorly commented (PercentageComment)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  PercentageComment < 20 AND 
  NbLinesOfCode > 10  
  ORDER BY PercentageComment ASC

// METHODS WHERE %Comment < 20 and that have 
// at least 10 lines of code should be more commented.
// See the definition of the PercentageComment metric here 
// http://www.ndepend.com/Metrics.aspx#PercentageComment]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods with too many parameters (NbParameters)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  NbParameters > 5 
  ORDER BY NbParameters DESC

// METHODS WHERE NbParameters > 5 might be painful to call 
// and might degrade performance. You should prefer using 
// additional properties/fields to the declaring type to 
// handle numerous states. Another alternative is to provide 
// a class or structure dedicated to handle arguments passing 
// (for example see the class System.Diagnostics.ProcessStartInfo 
// and the method System.Diagnostics.Process.Start(ProcessStartInfo))
// See the definition of the NbParameters metric here 
// http://www.ndepend.com/Metrics.aspx#NbParameters]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods with too many local variables (NbVariables)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  NbVariables > 15 
  ORDER BY NbVariables DESC

// METHODS WHERE NbVariables > 8 are hard to understand and maintain.
// METHODS WHERE NbVariables > 15 are extremely complex 
// and should be split in smaller methods 
// (except if they are automatically generated by a tool).
// See the definition of the Nbvariables metric here 
// http://www.ndepend.com/Metrics.aspx#Nbvariables]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods with too many overloads (NbOverloads)</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  NbOverloads > 6 AND 
  !IsOperator // Don't report operator overload
  ORDER BY NbOverloads DESC

// METHODS WHERE NbOverloads > 6 might 
// be a problem to maintain and provoke higher coupling 
// than necessary. 
// This might also reveal a potential misused of the 
// C# and VB.NET language that since C#3 and VB9 support 
// object initialization. This feature helps reducing the number 
// of constructors of a class.
// See the definition of the NbOverloads metric here 
// http://www.ndepend.com/Metrics.aspx#NbOverloads]]></Query>
      <Group Name="Type Metrics" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Types too big - critical (NbLinesOfCode)</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
   NbLinesOfCode > 500 OR
   NbILInstructions > 3000
   ORDER BY NbLinesOfCode DESC

// METHODS WHERE NbLinesOfCode > 500 are extremely complex 
// and should be split in a smaller group of types. 
// (except if they are automatically generated by a tool).
// See the definition of the NbLinesOfCode metric here 
// http://www.ndepend.com/Metrics.aspx#NbLinesOfCode

// In average, a line of code is compiled to around
// 6 IL instructions. This is why the code metric
// NbILInstructions is used here, in case the 
// code metric NbLinesOfCode is un-available because
// of missing assemblies corresponding PDB files.
// See the definition of the NbILInstructions metric here 
// http://www.ndepend.com/Metrics.aspx#NbILInstructions

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with too many methods</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  NbMethods > 20 
  ORDER BY NbMethods DESC

// TYPES WHERE NbMethods > 20 might be hard to 
// understand and maintain 
// but there might be cases where it is relevant 
// to have a high value for NbMethods. 
// For example, the System.Windows.Forms.DataGridView 
// standard class has more than 1000 methods.
// See the definition of the NbMethods metric here 
// http://www.ndepend.com/Metrics.aspx#NbMethods]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with too many fields</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  NbFields > 20 AND 
  !IsEnumeration 
  ORDER BY NbFields DESC

// TYPES WHERE NbFields > 20 AND !IsEnumeration 
// might be hard to understand and maintain 
// but there might be cases where it is relevant 
// to have a high value for NbFields. 
// For example, the System.Windows.Forms.Control 
// standard class has more than 200 fields. 
// The value of the metric NbFields might be a better 
// indicator of complex type.
// See the definition of the NbFields metric here 
// http://www.ndepend.com/Metrics.aspx#NbFields]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with poor cohesion (LCOM)</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  LCOM > 0.8 AND 
  NbFields > 10 AND 
  NbMethods >10 
  ORDER BY LCOM DESC

// TYPES WHERE LCOM > 0.8 AND NbFields > 10 
// AND NbMethods >10 might be problematic. 
// However, it is very hard to avoid such 
// non-cohesive types. The LCOMHS metric
// is often considered as more efficient to 
// detect non-cohesive types.
// See the definition of the LCOM metric here 
// http://www.ndepend.com/Metrics.aspx#LCOM]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with poor cohesion (LCOMHS)</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  LCOMHS > 0.95 AND 
  NbFields > 10 AND 
  NbMethods >10 
  ORDER BY LCOMHS DESC

// TYPES WHERE LCOMHS > 1.0 AND NbFields > 10 AND 
// NbMethods >10 should be avoided. 
// Note that this rule is stronger 
// than the rule 
// TYPES WHERE LCOM > 0.8 AND NbFields > 10 AND NbMethods >10. 
// See the definition of the LCOMHS metric here 
// http://www.ndepend.com/Metrics.aspx#LCOMHS]]></Query>
      </Group>
    </Group>
    <Group Name="Design" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assembly should not contain namespaces dependency cycles</Name>
WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE
ContainsNamespaceDependencyCycle

// Dependency cycles between namespaces must be avoided
// in order to have a levelized and comprehensive design.
// More info available on the screencast 'Reduce the complexity'
// http://s3.amazonaws.com/NDependOnlineDemos/NDependReducingComplexity_viewlet_swf.html
// You can also read this article
// http://www.theserverside.net/tt/articles/showarticle.tss?id=ControllingDependencies

// For any assembly matched, to display internal namespaces dependency cycle(s),
// just right-click the assembly and select:
//   --> View internal Dependency Cycles on Graph   ... or ...
//   --> View internal Dependency Cycles on Matrix (Recommended)
//  In the Matrix, dependency cycles are represented with red squares and black cells.
//  To browse easily dependency cycles, the Matrix comes with the option:
//   --> Display Direct and Indirect Dependencies
    ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid partitioning the code base through too many Assemblies</Name>
WARN IF Count > 50 IN
SELECT ASSEMBLIES WHERE !IsFrameworkAssembly

// Each .NET Assembly represents one or several physical file.
// Having too many .NET Assemblies is a symptom of considering
// physical .NET Assemblies as logical components.
// We advise having less, and bigger, .NET Assemblies
// and using the concept of namespaces to define logical components.
// Benefits are:
//  - Much faster compilation time
//    (compilation time divided by 10 wouldn't be surprising)
//  - Faster startup time for your program
//  - Easier deploiement thanks to less files to manage.
//  - If you are developing a Framework,
//    less .NET assemblies to reference and manage for your users
//
// More information can be found here:
// http://codebetter.com/blogs/patricksmacchia/archive/2008/12/08/advices-on-partitioning-code-through-net-assemblies.aspx
    ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Type should not have too many responsibilities (Efferent Coupling)</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  TypeCe > 50 
  ORDER BY TypeCe DESC 

// The Efferent Coupling (TypeCe) for a particular type is 
// the number of types it directly depends on. Notice that 
// types declared in third party assemblies are taken into account. 

// Types that depends on too many others type (more than 50) 
// are complex and have more than one responsibility. They 
// are good candidate for refactoring.

// More information available in this article:
// http://codebetter.com/blogs/patricksmacchia/archive/2008/02/15/code-metrics-on-coupling-dead-code-design-flaws-and-re-engineering.aspx

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>A stateless class or structure might be turned into a static type</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE
  SizeOfInst ==0 AND

  // For accuracy, this rule doesn't take
  // account of types that implement some interfaces.
  // and classes that have a base class and don't
  // derive directly from System.Object, or classes
  // that have sub-classes children.  
  NbInterfacesImplemented == 0 AND                           
  ((IsClass AND DepthOfInheritance == 1   
            AND NbChildren == 0)          
    OR IsStructure) AND                   
  !IsStatic AND
  !IsGeneric
  // this rule indicates stateless types that might 
  // eventually be turned into static classes.
  // See the definition of the SizeOfInst metric here 
  // http://www.ndepend.com/Metrics.aspx#SizeOfInst]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Class shouldn't be too deep in inheritance tree </Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  DepthOfInheritance >= 6 
  ORDER BY DepthOfInheritance DESC 

// Branches too long in the derivation should be avoided.
// See the definition of the DepthOfInheritance metric here 
// http://www.ndepend.com/Metrics.aspx#DIT
 
// You can discard specific classes with by-design high 
// DepthOfInheritance with such condition for example:
// AND !DeriveFrom "System.Windows.Forms.Form" ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Class with no descendant should be sealed if possible</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsClass AND 
  NbChildren ==0 AND 
  !IsSealed AND 
  !IsStatic 
  // AND !IsPublic <-- You might want to add this condition 
  //                   if you are developping a framework
  //                   with classes that are intended to be 
  //                   sub-classed by your clients.
  ORDER BY NbLinesOfCode]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Classes that are candidate to be turned into Structures</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsClass AND
  !IsStatic AND
  SizeOfInst > 0 AND
  SizeOfInst <= 16 AND    // Structure instance must not be too big, 
                          // else it degrades performance.

  NbChildren == 0 AND     // Must not have children

  DepthOfInheritance == 1 // Must derive directly from System.Object

  // AND IsSealed    <-- You might want to add this condition 
  //                     to restreint the set.
  // AND IsImmutable <-- Structures should be immutable type.
  // AND !IsPublic   <-- You might want to add this condition if 
  //                     you are developping a framework with classes 
  //                     that are intended to be sub-classed by 
  //                     your clients.
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid namespaces with few types</Name>
WARN IF Count > 0 IN SELECT NAMESPACES WHERE 
  NbTypes < 5 
  ORDER BY NbTypes ASC 

// Make sure that there is a logical organization 
// to each of your namespaces, and that there is a 
// valid reason for putting types in a sparsely 
// populated namespace. Namespaces should contain 
// types that are used together in most scenarios. 
// When their applications are mutually exclusive, 
// types should be located in separate namespaces]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Nested types should not be visible</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsNested AND 
  !IsPrivate AND 
  !IsInFrameworkAssembly 

// A nested type is a type declared within the 
// scope of another type. Nested types are useful 
// for encapsulating private implementation details 
// of the containing type. Used for this purpose, 
// nested types should not be externally visible. 
// Do not use externally visible nested types for 
// logical grouping or to avoid name collisions; 
// instead, use namespaces.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid empty interfaces</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsInterface AND 
  NbMethods == 0

// Interfaces define members that provide a behavior 
// or usage contract. The functionality described by 
// the interface can be adopted by any type, 
// regardless of where the type appears in the 
// inheritance hierarchy. A type implements an 
// interface by providing implementations for the 
// interface's members. An empty interface does not 
// define any members, and as such, does not define 
// a contract that can be implemented.

// If your design includes empty interfaces that 
// types are expected to implement, you are probably 
// using an interface as a marker, or a way of 
// identifying a group of types. If this identification 
// will occur at runtime, the correct way to accomplish
// this is to use a custom attribute. Use the presence 
// or absence of the attribute, or the attribute's 
// properties, to identify the target types. If the 
// identification must occurs at compile time, then using 
// an empty interface is acceptable.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid interfaces with too many methods</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsInterface AND 
  NbMethods > 20

// An interface should abstract a clear and well-defined concept.
// Such concept shoudln't be represented with too many methods.
// Here the metric NbMethods might be a bit biased by the fact
// that a read/write property lead to 2 accessor methods,
// the getter and the setter. The same remark applies with event 
// add and remove accessor.
// See the definition of the NbMethods metric here 
// http://www.ndepend.com/Metrics.aspx#NbMethods
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Declare types in namespaces</Name>
WARN IF Count > 0 IN SELECT NAMESPACES WHERE 
  NameIs "" AND 
  !IsInFrameworkAssembly 

// Types are declared within namespaces to 
// prevent name collisions, and as a way of 
// organizing related types in an object hierarchy. 
// Types outside any named namespace are in a 
// global namespace that cannot be referenced 
// in code. If an anonymous namespace can be found, 
// it means that it contains types outside of namespaces.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Empty static constructor can be discarded</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  IsClassConstructor AND 
  NbLinesOfCode == 0
    ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies with poor cohesion (RelationalCohesion)</Name>
WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  NbTypes > 20 AND // Relational Cohesion metrics is relevant only if there are several types 
  (RelationalCohesion < 1.5 OR 
   RelationalCohesion > 4.0)

// As classes inside an assembly should be strongly related, 
// the cohesion should be high. On the other hand, a value 
// which is too high may indicate over-coupling. A good range 
// for RelationalCohesion is 1.5 to 4.0.
// See the definition of the RelationalCohesion metric here 
// http://www.ndepend.com/Metrics.aspx#RelationalCohesion]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies that don't satisfy the Abstractness/Instability principle</Name>
WARN IF Percentage > 15 IN SELECT ASSEMBLIES WHERE 
  NormDistFromMainSeq > 0.7 
  ORDER BY NormDistFromMainSeq DESC

// See the definition of the NormDistFromMainSeq metric here 
// http://www.ndepend.com/Metrics.aspx#DitFromMainSeq]]></Query>
      <Group Name="Performance" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Instances size shouldn't be too big (SizeOfInst)</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  SizeOfInst > 64 
  ORDER BY SizeOfInst DESC

// TYPES WHERE SizeOfInst > 64 might degrade performance 
// (depending on the number of instances created at runtime) 
// and might be hard to maintain. However it is not a rule 
// since sometime there is no alternative (the size of 
// instances of the System.Net.NetworkInformation.SystemIcmpV6Statistics 
// standard class is 2064 bytes).
// See the definition of the SizeOfInst metric here 
// http://www.ndepend.com/Metrics.aspx#SizeOfInst]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Boxing/unboxing should be avoided (Method)</Name>
WARN IF Percentage > 5 IN SELECT METHODS WHERE 
  IsUsingBoxing OR 
  IsUsingUnboxing 

// Thanks to generics, boxing and unboxing should be rare.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Boxing/unboxing should be avoided (Type)</Name>
WARN IF Percentage > 5 IN SELECT TYPES WHERE 
  IsUsingBoxing OR 
  IsUsingUnboxing 

// Thanks to generics, boxing and unboxing should be rare.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Attribute classes should be sealed</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsAttributeClass AND 
  !IsSealed AND 
  !IsAbstract AND 
  IsPublic AND 
  !IsInFrameworkAssembly 

// The .NET Framework class library provides methods 
// for retrieving custom attributes. By default, 
// these methods search the attribute inheritance 
// hierarchy; for example System.Attribute.GetCustomAttribute 
// searches for the specified attribute type, or any 
// attribute type that extends the specified attribute 
// type. Sealing the attribute eliminates the search 
// through the inheritance hierarchy, and can improve 
// performance.]]></Query>
      </Group>
    </Group>
    <Group Name="Code Diff" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API Breaking Changes: Types</Name>
WARN IF Count > 0 IN SELECT TYPES
WHERE IsPublic AND (VisibilityWasChanged OR WasRemoved)

// This rule warns if a public type is not public anymore or if it has been removed.
// This can break the code of your clients.
// More information on breaking changes here: 
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx

// To run this rule properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Analysis Comparison


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods added</Name>
SELECT METHODS WHERE WasAdded

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods where code was changed</Name>
SELECT METHODS WHERE CodeWasChanged 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Public Types added</Name>
SELECT TYPES WHERE WasAdded AND IsPublic

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types added</Name>
SELECT TYPES WHERE WasAdded

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types where code was changed</Name>
SELECT TYPES WHERE CodeWasChanged 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces added</Name>
SELECT NAMESPACES WHERE WasAdded

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces where code was changed</Name>
SELECT NAMESPACES WHERE CodeWasChanged 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Types that were not used and that are now used</Name>
SELECT TYPES WHERE IsUsedRecently 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Methods that were not used and that are now used</Name>
SELECT METHODS WHERE IsUsedRecently 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
      <Group Name="API Breaking Changes" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API Breaking Changes: Methods</Name>
WARN IF Count > 0 IN SELECT METHODS
WHERE 
  IsPublic AND 
  (VisibilityWasChanged OR WasRemoved)

// This rule warns if a public method is 
// not public anymore or if it has been removed.
// This can break the code of your clients.
// More information on breaking changes here: 
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx

// To run this rule properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Analysis Comparison

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Types</Name>
WARN IF Count > 0 IN SELECT TYPES
WHERE IsPublic AND (VisibilityWasChanged OR WasRemoved)

// This rule warns if a public type is not public anymore or if it has been removed.
// This can break the code of your clients.
// More information on breaking changes here: 
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx

// To run this rule properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Analysis Comparison


]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Interfaces</Name>
WARN IF Count > 0 IN SELECT TYPES
WHERE IsInterface AND IsPublic AND (WasChanged AND !CommentsWereChanged)

// This rule warns if a public interface has been changed, but not because of comment change.
// This can break the code of your clients that implements such interface.
// More information on breaking changes here: 
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/20/avoid-api-breaking-changes.aspx

// To run this rule properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Analysis Comparison]]></Query>
      </Group>
      <Group Name="Changes Summary" Active="False" ShownInReport="False">
        <Group Name="Methods" Active="False" ShownInReport="False">
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods added</Name>
SELECT METHODS WHERE WasAdded

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison
]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods removed</Name>
SELECT METHODS WHERE WasRemoved 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods where code was changed</Name>
SELECT METHODS WHERE CodeWasChanged 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods where comments were changed</Name>
SELECT METHODS WHERE CommentsWereChanged  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods where visibility was changed</Name>
SELECT METHODS WHERE VisibilityWasChanged  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that became obsolete</Name>
SELECT METHODS WHERE BecameObsolete  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
        </Group>
        <Group Name="Fields" Active="False" ShownInReport="False">
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields added</Name>
SELECT FIELDS WHERE WasAdded

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields removed</Name>
SELECT FIELDS WHERE WasRemoved 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
        </Group>
        <Group Name="Types" Active="False" ShownInReport="False">
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types added</Name>
SELECT TYPES WHERE WasAdded

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types removed</Name>
SELECT TYPES WHERE WasRemoved 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types where code was changed</Name>
SELECT TYPES WHERE CodeWasChanged 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types where comments were changed</Name>
SELECT TYPES WHERE CommentsWereChanged  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types where visibility was changed</Name>
SELECT TYPES WHERE VisibilityWasChanged  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that became obsolete</Name>
SELECT TYPES WHERE BecameObsolete  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
        </Group>
        <Group Name="Namespaces" Active="False" ShownInReport="False">
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces added</Name>
SELECT NAMESPACES WHERE WasAdded

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces removed</Name>
SELECT NAMESPACES WHERE WasRemoved 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces where code was changed</Name>
SELECT NAMESPACES WHERE CodeWasChanged 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces where comments were changed</Name>
SELECT NAMESPACES WHERE CommentsWereChanged  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
        </Group>
        <Group Name="Assemblies" Active="False" ShownInReport="False">
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies added</Name>
SELECT ASSEMBLIES WHERE WasAdded

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies removed</Name>
SELECT ASSEMBLIES WHERE WasRemoved 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies where code was changed</Name>
SELECT ASSEMBLIES WHERE CodeWasChanged 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies where comments were changed</Name>
SELECT ASSEMBLIES WHERE CommentsWereChanged  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
        </Group>
        <Group Name="Third party Code Usage" Active="False" ShownInReport="False">
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Methods that were not used and that are now used</Name>
SELECT METHODS WHERE IsUsedRecently 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Methods that were used and that are not used anymore</Name>
SELECT METHODS WHERE IsNotUsedAnymore  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Types that were not used and that are now used</Name>
SELECT TYPES WHERE IsUsedRecently 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Types that were used and that are not used anymore</Name>
SELECT TYPES WHERE IsNotUsedAnymore  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Types where usage changed</Name>
SELECT TYPES WHERE IsUsedDifferently 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Namespaces that were not used and that are now used</Name>
SELECT NAMESPACES WHERE IsUsedRecently 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Namespaces that were used and that are not used anymore</Name>
SELECT NAMESPACES WHERE IsNotUsedAnymore  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Namespaces where usage changed</Name>
SELECT NAMESPACES WHERE IsUsedDifferently 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Assemblies that were not used and that are now used</Name>
SELECT ASSEMBLIES WHERE IsUsedRecently 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Assemblies that were used and that are not used anymore</Name>
SELECT ASSEMBLIES WHERE IsNotUsedAnymore  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Assemblies where usage changed</Name>
SELECT ASSEMBLIES WHERE IsUsedDifferently 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Fields that were not used and that are now used</Name>
SELECT FIELDS WHERE IsUsedRecently 

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
          <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party Fields that were used and that are not used anymore</Name>
SELECT FIELDS WHERE IsNotUsedAnymore  

// To run this query properly 2 analysis 
// must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison]]></Query>
        </Group>
      </Group>
    </Group>
    <Group Name="Code Coverage" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Complex methods should be 100% covered by tests</Name>
WARN IF Count > 0 IN SELECT METHODS 
 /*OUT OF "YourGeneratedCode" */ 
 WHERE 
     // These metrics' definitions are available here: 
     // http://www.ndepend.com/Metrics.aspx#MetricsOnMethods
     (  NbLinesOfCode > 30 OR 
        ILCyclomaticComplexity > 50 OR 
        ILNestingDepth > 4 OR
        NbParameters > 5 OR 
        NbVariables > 8 OR
        NbOverloads > 6 ) AND 

     // Take care only of complex methods 
     // already covered a bit, but not completely covered.
     PercentageCoverage > 0 AND
     PercentageCoverage < 100

  ORDER BY NbLinesOfCode DESC, 
           NbLinesOfCodeNotCovered ,
           PercentageCoverage  

// To run this rule properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method changed poorly covered</Name>
SELECT METHODS WHERE 
  PercentageCoverage < 30 AND 
  CodeWasChanged 
  ORDER BY NbLinesOfCode DESC, 
           NbLinesOfCodeNotCovered ,
           PercentageCoverage  

// To run this query properly 2 analysis must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method added poorly covered</Name>
SELECT METHODS WHERE
  PercentageCoverage < 30 AND 
  WasAdded 
  ORDER BY NbLinesOfCode DESC, 
           NbLinesOfCodeNotCovered ,
           PercentageCoverage 

// To run this query properly 2 analysis must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types 95% to 99% covered</Name>
SELECT TYPES WHERE 
  PercentageCoverage >= 95 AND 
  PercentageCoverage <= 99 
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered ,
           PercentageCoverage 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.asp]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces 95% to 99% covered</Name>
SELECT NAMESPACES WHERE 
  PercentageCoverage >= 95 AND 
  PercentageCoverage <= 99 
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered ,
           PercentageCoverage 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types not covered</Name>
SELECT TYPES WHERE 
  PercentageCoverage == 0
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered ,
           PercentageCoverage 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces not covered</Name>
SELECT NAMESPACES WHERE 
  PercentageCoverage == 0
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered ,
           PercentageCoverage 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
      <Group Name="Test Coverage Summary" Active="False" ShownInReport="False">
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods 100% covered</Name>
SELECT METHODS WHERE 
  PercentageCoverage == 100

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types 100% covered</Name>
SELECT TYPES WHERE 
  PercentageCoverage == 100

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces 100% covered</Name>
SELECT NAMESPACES WHERE 
  PercentageCoverage == 100

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies 100% covered</Name>
SELECT ASSEMBLIES WHERE 
  PercentageCoverage == 100

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods not covered</Name>
SELECT METHODS WHERE 
  PercentageCoverage == 0
  ORDER BY NbLinesOfCode DESC

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types not covered</Name>
SELECT TYPES WHERE 
  PercentageCoverage == 0
  ORDER BY NbLinesOfCode DESC

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces not covered</Name>
SELECT NAMESPACES WHERE 
  PercentageCoverage == 0
  ORDER BY NbLinesOfCode DESC

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies not covered</Name>
SELECT ASSEMBLIES WHERE 
  PercentageCoverage == 0
  ORDER BY NbLinesOfCode DESC

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods 95% to 99% covered</Name>
SELECT METHODS WHERE 
  PercentageCoverage >= 95 AND 
  PercentageCoverage <= 99 
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies 95% to 99% covered</Name>
SELECT ASSEMBLIES WHERE 
  PercentageCoverage >= 95 AND 
  PercentageCoverage <= 99 
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods 70% to 94% covered</Name>
SELECT METHODS WHERE 
  PercentageCoverage >= 70 AND 
  PercentageCoverage <= 94
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types 70% to 94% covered</Name>
SELECT TYPES WHERE 
  PercentageCoverage >= 70 AND 
  PercentageCoverage <= 94
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces 70% to 94% covered</Name>
SELECT NAMESPACES WHERE 
  PercentageCoverage >= 70 AND 
  PercentageCoverage <= 94
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies 70% to 94% covered</Name>
SELECT ASSEMBLIES WHERE 
  PercentageCoverage >= 70 AND 
  PercentageCoverage <= 94
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods 1% to 69% covered</Name>
SELECT METHODS WHERE 
  PercentageCoverage >= 1 AND 
  PercentageCoverage <= 69
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types 1% to 69% covered</Name>
SELECT TYPES WHERE 
  PercentageCoverage >= 1 AND 
  PercentageCoverage <= 69
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces 1% to 69% covered</Name>
SELECT NAMESPACES WHERE 
  PercentageCoverage >= 1 AND 
  PercentageCoverage <= 69
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assemblies 1% to 69% covered</Name>
SELECT ASSEMBLIES WHERE 
  PercentageCoverage >= 1 AND 
  PercentageCoverage <= 69
  ORDER BY NbLinesOfCode DESC , 
           NbLinesOfCodeNotCovered 

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
      </Group>
      <Group Name="Coverage Regression" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Coverage regression on methods 100% covered by tests</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  HasAttribute "OPTIONAL:NDepend.CQL.FullCoveredAttribute" AND 
  PercentageCoverage < 100

// NDepend.CQL.FullCoveredAttribute is defined in the 
// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 
/// '100% covered' methods.

// To run this rule properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Coverage regression on methods 100% Branch-covered by tests</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  HasAttribute "OPTIONAL:NDepend.CQL.FullBranchCoveredAttribute" AND 
  PercentageBranchCoverage < 100

// NDepend.CQL.FullCoveredAttribute is defined in the 
// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 
// '100% branch covered' methods.

// To run this rule properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx

// The metric BranchCoverage is not available if you are using Visual Studio™ Coverage.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Coverage regression on type 100% covered by tests</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  HasAttribute "OPTIONAL:NDepend.CQL.FullCoveredAttribute" AND 
  PercentageCoverage < 100

// NDepend.CQL.FullCoveredAttribute is defined in the 
// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 
// '100% covered' types.

// To run this rule properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Coverage regression on assembly 100% covered by tests</Name>
WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  HasAttribute "OPTIONAL:NDepend.CQL.FullCoveredAttribute" AND 
  PercentageCoverage < 100

// NDepend.CQL.FullCoveredAttribute is defined in the 
// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 
// '100% covered' assemblies.

// To run this rule properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Coverage regression on methods at least 95% covered by tests</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  HasAttribute "OPTIONAL:NDepend.CQL.MoreThan95PercentCoveredAttribute" AND 
  PercentageCoverage < 95

// NDepend.CQL.FullCoveredAttribute is defined in the 
// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 
// 'at least 95% Covered' methods.

// To run this rule properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Coverage regression on types at least 95% covered by tests</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  HasAttribute "OPTIONAL:NDepend.CQL.MoreThan95PercentCoveredAttribute" AND 
  PercentageCoverage < 95

// NDepend.CQL.FullCoveredAttribute is defined in the 
// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 
// 'at least 95% Covered' types.

// To run this rule properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Coverage regression on assemblies at least 95% covered by tests</Name>
WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  HasAttribute "OPTIONAL:NDepend.CQL.MoreThan95PercentCoveredAttribute" AND 
  PercentageCoverage < 95

// NDepend.CQL.FullCoveredAttribute is defined in the 
// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 
// 'at least 95% Covered' assemblies.

// To run this rule properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
      </Group>
      <Group Name="Coverage of Changes Summary" Active="False" ShownInReport="False">
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method changed 100% covered by tests</Name>
SELECT METHODS WHERE 
  PercentageCoverage == 100 AND 
  CodeWasChanged 
  ORDER BY NbLinesOfCode DESC 

// To run this query properly 2 analysis must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method added 100% covered by tests</Name>
SELECT METHODS WHERE 
  WasAdded AND 
  PercentageCoverage == 100 
  ORDER BY NbLinesOfCode DESC 

// To run this query properly 2 analysis must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method changed partially covered by tests</Name>
SELECT METHODS WHERE 
  PercentageCoverage < 100 AND 
  PercentageCoverage > 0 AND
  CodeWasChanged 
  ORDER BY PercentageCoverage DESC , 
           NbLinesOfCodeCovered , 
           NbLinesOfCodeNotCovered 

// To run this query properly 2 analysis must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method added partially covered by tests</Name>
SELECT METHODS WHERE 
  PercentageCoverage < 100 AND 
  PercentageCoverage > 0 AND
  WasAdded  
  ORDER BY PercentageCoverage DESC , 
           NbLinesOfCodeCovered , 
           NbLinesOfCodeNotCovered 

// To run this query properly 2 analysis must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method changed not covered at all</Name>
SELECT METHODS WHERE 
  PercentageCoverage == 0 AND 
  CodeWasChanged 
  ORDER BY NbLinesOfCode DESC 

// To run this query properly 2 analysis must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method added not covered at all</Name>
SELECT METHODS WHERE 
  PercentageCoverage == 0 AND 
  WasAdded 
  ORDER BY NbLinesOfCode DESC 

// To run this query properly 2 analysis must be compared.
// This can be done throught the menu: 
//   NDepend -> Compare -> Define the project's Baseline for Comparison

// To run this query properly coverage data must be 
// gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
      </Group>
    </Group>
    <Group Name="Dead Code" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Potentially unused types</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
 TypeCa == 0 AND    // Ca=0 -> No Afferent Coupling -> 
                    // The type is not used in the 
                    // context of this application.

         // Type Afferent Coupling metric definition
         // http://www.ndepend.com/Metrics.aspx#TypeCa

 !IsPublic AND      // Public and Protected types 
 !IsProtected AND   // might be used by client 
                    // applications of your assemblies.

 !NameIs "Program"  // Generally, types named Program 
                    // contain a Main() entry-point 
                    // method and this condition avoid 
                    // to consider such type as 
                    // unused code.

// Caution: Types used only by reflection might be matched.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Potentially unused methods</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
 MethodCa == 0 AND        // Ca=0 -> No Afferent Coupling -> 
                          // The method is not used in the 
                          // context of this application.

         // Method  Afferent Coupling metric definition
         // http://www.ndepend.com/Metrics.aspx#MethodCa

 !IsPublic AND            // Public and Protected methods 
 !IsProtected AND         // might be used by client 
                          // applications of your assemblies..

 !IsEntryPoint AND        // Main() method is not used by-design.

 !IsExplicitInterfaceImpl // The IL code never explicitely 
 AND                      // calls explicit interface methods 
                          // implementation.
 
 !IsClassConstructor AND  // The IL code never explicitely 
                          // calls class constructors.

 !IsFinalizer             // The IL code never explicitely 
                          // calls finalizers.

// Caution: Methods used only by reflection might be matched.
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Potentially unused fields</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
 FieldCa == 0 AND  // Ca=0 -> No Afferent Coupling -> 
                   // The field is not used in the 
                   // context of this application.

      // Field Afferent Coupling metric definition
      // http://www.ndepend.com/Metrics.aspx#FieldCa

 !IsPublic AND     // Although not recommended, 
 !IsProtected AND  // Public and Protected fields  
                   // might be used by client 
                   // applications of your assemblies.

 !IsLiteral AND    // The IL code never explicitely 
                   // uses literal fields.

 !IsEnumValue AND  // The IL code never explicitely 
                   // uses enumeration value.

 !NameIs "value__" // Field named 'value__' are relative 
                   // to enumerations and the IL code 
                   // never explicitely uses them.

// Caution: Fields used only by reflection might be matched.]]></Query>
    </Group>
    <Group Name="Code Quality from Now!" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all methods added or refactored should respect basic quality principles</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE

// *** Only new or modified methods since Baseline for Comparison ***
 (WasAdded OR CodeWasChanged) AND

// Low Quality methods// Metrics' definitions
(  NbLinesOfCode > 30 OR    // http://www.ndepend.com/Metrics.aspx#NbLinesOfCode
   NbILInstructions > 200 OR// http://www.ndepend.com/Metrics.aspx#NbILInstructions
   CyclomaticComplexity > 20 OR   // http://www.ndepend.com/Metrics.aspx#CC
   ILCyclomaticComplexity > 50 OR // http://www.ndepend.com/Metrics.aspx#ILCC
   ILNestingDepth > 4 OR    // http://www.ndepend.com/Metrics.aspx#ILNestingDepth
   NbParameters > 5 OR// http://www.ndepend.com/Metrics.aspx#NbParameters
   NbVariables > 8 OR // http://www.ndepend.com/Metrics.aspx#NbVariables
   NbOverloads > 6 )  // http://www.ndepend.com/Metrics.aspx#NbOverloads


// This rule warns if a method with
// low-quality has been added or refactored.
// With NDepend and such rule, you can
// Ensure Quality From Now! as explained here:
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx

// To run this rule properly 2 analysis
// must be compared. This can be done throught the menu:
//     NDepend -> Compare -> Define the project's Baseline for Comparison
// This can be done at analysis time throught the menu:
//   Project Properties -> Analysis -> Analysis Comparison
    ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all types added or refactored should respect basic quality principles</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE

// *** Only match new or modified types since Baseline for Comparison ***
(WasAdded OR CodeWasChanged) AND

// Low Quality types     Metrics' definitions are available here:
//     http://www.ndepend.com/Metrics.aspx#MetricsOnTypes
(  // Types with too many methods
   NbMethods > 20 OR

   // Types with too many fields
   ( NbFields > 20 AND
    !IsEnumeration) OR

   // Types with poor cohesion
   ( LCOMHS > 0.95 AND
     NbFields > 10 AND
     NbMethods > 10) OR

   // Complex Types that use more than 50 other types
   TypeCe > 50  )


// This rule warns if a type with
// low-quality has been added or refactored.
// With NDepend and such rule, you can
// Ensure Quality From Now! as explained here:
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx

// To run this rule properly 2 analysis
// must be compared. This can be done throught the menu:
//     NDepend -> Compare -> Define the project's Baseline for Comparison
// This can be done at analysis time throught the menu:
//   Project Properties -> Analysis -> Analysis Comparison]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all methods added or refactored should be 100% covered by tests</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE

// Match methods new or modified since Baseline for Comparison...
  (WasAdded OR CodeWasChanged) AND

// ...that are not 100% covered by tests
  PercentageCoverage < 100


// This rule warns if a method has been
// added or refactored and hasn't been 100% covered
// by tests. With NDepend and such rule,
// you can Ensure Quality From Now! as explained here:
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/01/ensure-the-quality-of-the-code-that-will-be-developed-this-year.aspx

// To run this rule properly 2 analysis
// must be compared. This can be done throught the menu:
//     NDepend -> Compare -> Define the project's Baseline for Comparison
// This can be done at analysis time throught the menu:
//   Project Properties -> Analysis -> Analysis Comparison

// To run this rule properly coverage data
// must be gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu:
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu:
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx]]></Query>
    </Group>
    <Group Name="Encapsulation" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields should be declared as private</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
 !IsPrivate AND 

 // These conditions filter cases where fields 
 // doesn't represent state that should be encapsulated. 
 !IsInFrameworkAssembly AND 
 !IsGeneratedByCompiler AND 
 !IsSpecialName AND 
 !IsInitOnly AND 
 !IsLiteral AND 
 !IsEnumValue]]></Query>
      <Group Name="Methods Optimal Encapsulation" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that could be declared as 'internal' in C#, 'Friend' in VB.NET</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  CouldBeInternal AND
  
  // Eliminate default constructor from the result.
  // Whatever the visibility of the declaring class,
  // default constructors are public and introduce noise
  // in the current rule.
  ! ( IsConstructor AND 
      IsPublic AND 
      NbILInstructions == 3)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that could be declared as 'protected internal' in C#, 'Protected Friend' in VB.NET</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  CouldBeInternalProtected]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that could be declared as 'protected' in C#, 'Protected' in VB.NET</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  CouldBeProtected]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that could be declared as 'private' in C#, 'Private' in VB.NET</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  CouldBePrivate]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that should be declared as 'public' in C#, 'Public' in VB.NET</Name>
SELECT METHODS WHERE 
  ShouldBePublic 

// The keyword 'ShouldBePublic' shows code elements 
// declared as 'internal\Friend' that are used outside 
// of their assembly thanks to the Attribute 
// System.Runtime.CompilerServices.InternalsVisibleTo]]></Query>
      </Group>
      <Group Name="Types Optimal Encapsulation" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that could be declared as internal</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  CouldBeInternal]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that could be declared as 'protected internal' in C#, 'Protected Friend' in VB.NET</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  CouldBeInternalProtected]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that could be declared as 'protected' in C#, 'Protected' in VB.NET</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  CouldBeProtected]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that could be declared as 'private' in C#, 'Private' in VB.NET</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  CouldBePrivate]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that should be declared as 'public' in C#, 'Public' in VB.NET</Name>
SELECT TYPES WHERE 
  ShouldBePublic 

// The keyword 'ShouldBePublic' shows code elements 
// declared as 'internal\Friend' that are used 
// outside of their assembly thanks to the Attribute 
// System.Runtime.CompilerServices.InternalsVisibleTo]]></Query>
      </Group>
      <Group Name="Fields Optimal Encapsulation" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields that could be declared as internal</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
  CouldBeInternal]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields that could be declared as 'protected internal' in C#, 'Protected Friend' in VB.NET</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
  CouldBeInternalProtected]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields that could be declared as 'protected' in C#, 'Protected' in VB.NET</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
  CouldBeProtected]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields that could be declared as 'private' in C#, 'Private' in VB.NET</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
  CouldBePrivate]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields that should be declared as 'public' in C#, 'Public' in VB.NET</Name>
SELECT FIELDS WHERE 
  ShouldBePublic 

// The keyword 'ShouldBePublic' shows code elements 
// declared as 'internal\Friend' that are used 
// outside of their assembly thanks to the Attribute 
// System.Runtime.CompilerServices.InternalsVisibleTo]]></Query>
      </Group>
    </Group>
    <Group Name="Purity - Immutability - Side-Effects" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields should be marked as ReadOnly when possible</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
  IsImmutable AND 
  !IsInitOnly AND
  !IsGeneratedByCompiler AND
  !IsEventDelegateObject 

// A field that matches the condition IsImmutable 
// is a field that is assigned only by constructors 
// of its class.
// For an instance field, this means its value 
// will remain constant throught the lifetime 
// of the object.
// For a static field, this means its value will 
// remain constant throught the lifetime of the 
// program.
// In both cases, such field can safely be marked 
// with the C# readonly keyword 
// (ReadOnly in VB.NET).

// The condition IsInitOnly matches fields that 
// are marked with the C# readonly keyword 
// (ReadOnly in VB.NET).



]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Structures should be immutable</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsStructure AND 
  !IsImmutable AND 
  !IsInFrameworkAssembly

// It is deemed as a good practice to make 
// your structure immutable.
// An object is immutable if its state doesn’t 
// change once the object has been created. 
// Consequently, a structure is immutable if 
// its instances are immutable.
// Immutable types naturally simplify code by 
// limiting side-effects.
// See some explanations on immutability and 
// how NDepend supports it here:
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx
]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Regression on immutable types</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  HasAttribute "OPTIONAL:NDepend.CQL.ImmutableAttribute" AND 
  !IsImmutable

// An object is immutable if its state doesn’t 
// change once the object has been created. 
// Consequently, a class or a structure is 
// immutable if its instances are immutable.
// Immutable types naturally simplify code by 
// limiting side-effects.
// See some explanations on immutability and how 
// NDepend supports it here:
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx

// NDepend.CQL.ImmutableAttribute is defined in 
// the redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 
// 'immutable' types.

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Regression on pure methods</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  HasAttribute "OPTIONAL:NDepend.CQL.PureAttribute" AND 
  ( ChangesObjectState OR ChangesTypeState ) AND
  NbLinesOfCode > 0

// A method is pure if its execution doesn’t change 
// the value of any instance or static field. 
// Pure methods naturally simplify code by limiting 
// side-effects.
// See some explanations on immutability - purity and 
// how NDepend supports it here:
// http://codebetter.com/blogs/patricksmacchia/archive/2008/01/13/immutable-types-understand-them-and-use-them.aspx

// NDepend.CQL.PureAttribute is defined in the 
// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 'pure' methods.

]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Missing usage of ImmutableAttribute</Name>
SELECT TYPES WHERE 
  !HasAttribute "OPTIONAL:NDepend.CQL.ImmutableAttribute" AND 
  IsImmutable

// Types matched by this query are immutable but 
// are not tagged with the ImmutableAttribute.
// The benefit of tagging them with the ImmutableAttribute 
// is that the rule 'Regression on immutable types' 
// will warn when the immutability of a type gets broken.

// NDepend.CQL.ImmutableAttribute is defined in the 
// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 'immutable' types.
]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Missing usage of PureAttribute</Name>
SELECT METHODS WHERE 
  !HasAttribute "OPTIONAL:NDepend.CQL.PureAttribute" AND 
  !ChangesObjectState AND !ChangesTypeState AND
  NbLinesOfCode > 0

// Methods matched by this query are pure but 
// are not tagged with the PureAttribute.
// The benefit of tagging them with the PureAttribute 
// is that the rule 'Regression on pure methods'
// will warn when the purity of a method gets broken.

// NDepend.CQL.PureAttribute is defined in the 
// redistributable assembly $NDependInstallDir$\Lib\NDepend.CQL.dll
// You can define your own attribute to tag 'pure' methods.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Instance Property Getter should be immutable</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE
IsPropertyGetter AND
!IsStatic AND
ChangesObjectState

// This rule might be violated in the case of object lazy initialized
// when the property getter is accessed the first time.
    ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Static Property Getter should be immutable</Name>
WARN IF Count > 0 IN SELECT METHODS  WHERE
IsPropertyGetter AND
IsStatic AND
ChangesTypeState

// Generated property getter Resources.get_ResourceManager()
// provokes a read-only property lazy-initialized
AND !FullNameLike "Resources.get_ResourceManager()"

// This rule might be violated in the case of object lazy initialized
// when the property getter is accessed the first time.
    ]]></Query>
    </Group>
    <Group Name="Naming Conventions" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Instance fields should be prefixed with a 'm_'</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
  !NameLike "^m_" AND 
  !IsStatic AND 
  !IsLiteral AND 
  !IsGeneratedByCompiler  AND 
  !IsSpecialName AND 
  !IsEventDelegateObject 

// This naming convention provokes debate.
// Don't hesitate to customize the regex of 
// NameLike to your preference.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Static fields should be prefixed with a 's_'</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
  !NameLike "^s_" AND 
  IsStatic AND 
  !IsLiteral AND 
  !IsGeneratedByCompiler AND 
  !IsSpecialName AND 
  !IsEventDelegateObject  

// This naming convention provokes debate.
// Don't hesitate to customize the regex of 
// NameLike to your preference.
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Interface name should begin with a 'I'</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsInterface AND 
  !NameLike "^I" AND 
  !IsNested AND 
  !IsInFrameworkAssembly
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Abstract base class should be suffixed with 'Base'</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsAbstract AND 
  IsClass AND

  // equivalent to:   DepthOfDeriveFrom "System.Object" == 1
  DepthOfInheritance == 1 AND 

  ((!IsGeneric AND !NameLike "Base$") OR
   ( IsGeneric AND !NameLike "Base<"))
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Exception class name should be suffixed with 'Exception'</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsExceptionClass AND 
  !NameLike "Exception$" AND 
  !IsInFrameworkAssembly

// The name of an exception class should end with 
// 'Exception'.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Attribute class name should be suffixed with 'Attribute'</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  IsAttributeClass AND 
  !NameLike "Attribute$" AND 
  !IsInFrameworkAssembly
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types name should begin with an Upper character</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  // The name of a type should begin with an Upper letter.
  !NameLike "^[A-Z]" AND     

  // Except if it is generated by compiler or ...
  !IsGeneratedByCompiler AND 

  // ... if it is declared in a third party assembly.
  !IsInFrameworkAssembly     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods name should begin with an Upper character</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  !NameLike "^[A-Z]" AND 
  !( IsClassConstructor OR IsConstructor OR 
     IsPropertyGetter  OR IsPropertySetter OR
     IsIndexerGetter OR IsIndexerSetter OR
     IsEventAdder OR IsEventRemover OR
     IsOperator) AND 
  !IsGeneratedByCompiler AND 
  !IsInFrameworkAssembly

// The name of a regular method should 
// begin with an Upper letter.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Do not name enum values 'Reserved'</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
  IsEnumValue AND 
  NameLike "Reserved"

// This rule assumes that an enumeration member 
// with a name that contains "reserved" 
// is not currently used but is a placeholder to 
// be renamed or removed in a future version.
// Renaming or removing a member is a breaking 
// change. You should not expect users to ignore
// a member just because its name contains 
// "reserved" nor can you rely on users to read or 
// abide by documentation. Furthermore, because 
// reserved members appear in object browsers 
// and smart integrated development environments, 
// they can cause confusion as to which members 
// are actually being used.

// Instead of using a reserved member, add a 
// new member to the enumeration in the future 
// version.
// In most cases, the addition of the new 
// member is not a breaking change, as long as the 
// addition does not cause the values of the 
// original members to change.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Type names should not match namespaces</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  NameIs "Collections" OR
  NameIs "Forms" OR
  NameIs "System" OR
  NameIs "UI"

// Type names should not match the names of 
// namespaces defined in the .NET Framework 
// class library. Violating this rule can reduce 
// the usability of the library.]]></Query>
      <Group Name="Name too long" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with name too long</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  NameLike "^[^\<\(]{35,}.*$" AND
  !IsExplicitInterfaceImpl AND 
  !IsInFrameworkAssembly

// The regex matches methods with name longer 
// than 35 characters.
// Method Name doesn't contain the type and namespace 
// prefix, FullName does.
// The regex computes the method name length from 
// the beginning until the first open parenthesis 
// or first lower than (for generic methods).
// Explicit Interface Implementation methods are 
// discarded because their names are prefixed 
// with the interface name.
      ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with name too long</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE
  NameLike "^[^\<]{35,}.*$" AND
  !IsNested AND 
  !IsInFrameworkAssembly

// The regex matches types with name longer 
// than 35 characters.
// Type Name doesn't contain the namespace 
// prefix, FullName does.
// The regex computes the type name length from 
// the beginning until the end or the first lower than 
// (for generic types).
// Nested types are discarded because their 
// names are prefixed with outer type's name.
      ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid fields with name too long</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE
  NameLike "^[^\<]{35,}.*$" AND
  !IsInFrameworkAssembly

// The regex matches fields with name longer 
// than 35 characters.
// Field Name doesn't contain the type and 
// namespace prefix, FullName does.
      ]]></Query>
      </Group>
    </Group>
    <Group Name=".NET Framework Usage" Active="True" ShownInReport="False">
      <Group Name="System" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Mark ISerializable types with serializable</Name>
SELECT TYPES WHERE 
 IsPublic AND !IsDelegate AND
 Implement "OPTIONAL:System.Runtime.Serialization.ISerializable" AND 
 !HasAttribute "OPTIONAL:System.SerializableAttribute"

// To be recognized by the CLR as serializable, 
// types must be marked with the SerializableAttribute 
// attribute even if the type uses a custom 
// serialization routine through implementation of 
// the ISerializable interface.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Mark assemblies with assembly version</Name>
WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  !HasAttribute "OPTIONAL:System.Reflection.AssemblyVersionAttribute" AND
  !IsFrameworkAssembly 

// The identity of an assembly is composed of 
// the following information:
//    - Assembly name
//    - Version number
//    - Culture
//    - Public key (for strong-named assemblies).
// The .NET Framework uses the version number 
// to uniquely identify an assembly, and to bind 
// to types in strong-named assemblies. The 
// version number is used together with version 
// and publisher policy. By default, applications 
// run only with the assembly version with 
// which they were built.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Mark assemblies with CLSCompliant</Name>
WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  !HasAttribute "OPTIONAL:System.CLSCompliantAttribute" AND
  !IsFrameworkAssembly 

// The Common Language Specification (CLS) defines 
// naming restrictions, data types, and rules to which 
// assemblies must conform if they are to be used 
// across programming languages. Good design dictates 
// that all assemblies explicitly indicate CLS 
// compliance with CLSCompliantAttribute. If the 
// attribute is not present on an assembly, the 
// assembly is not compliant.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Mark assemblies with ComVisible</Name>
WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  !HasAttribute "OPTIONAL:System.Runtime.InteropServices.ComVisibleAttribute" AND
  !IsFrameworkAssembly 

// The ComVisibleAttribute attribute determines 
// how COM clients access managed code. Good design 
// dictates that assemblies explicitly indicate 
// COM visibility. COM visibility can be set for 
// an entire assembly and then overridden for 
// individual types and type members. If the 
// attribute is not present, the contents of 
// the assembly are visible to COM clients.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Mark attributes with AttributeUsageAttribute</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
DeriveFrom "OPTIONAL:System.Attribute" AND
!HasAttribute "OPTIONAL:System.AttributeUsageAttribute" AND
!IsInFrameworkAssembly 

// When defining a custom attribute, mark it using 
// AttributeUsageAttribute to indicate where in the 
// source code the custom attribute can be applied.
// An attribute's meaning and intended usage will 
// determine its valid locations in code. For example, 
// if you are defining an attribute that identifies 
// the person responsible for maintaining and enhancing 
// each type in a library, and responsibility is 
// always assigned at the type level, compilers should 
// allow the attribute on classes, enumerations, 
// and interfaces, but should not allow it on methods, 
// events, or properties. Organizational policies and
// procedures would dictate whether the attribute 
// should be allowed on assemblies.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Remove calls to GC.Collect()</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE
  IsDirectlyUsing "OPTIONAL:System.GC.Collect()" OR
  IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32)" OR
  IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32,GCCollectionMode)"

// It is preferrable to avoid calling GC.Collect() 
// explicitely in order to avoid some performance pitfall.
// More in information on this here:
// http://blogs.msdn.com/ricom/archive/2004/11/29/271829.aspx]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't call GC.Collect() without calling GC.WaitForPendingFinalizers()</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE
  (IsDirectlyUsing "OPTIONAL:System.GC.Collect()" OR
   IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32)" OR
   IsDirectlyUsing "OPTIONAL:System.GC.Collect(Int32,GCCollectionMode)") 
  AND
  !IsDirectlyUsing "OPTIONAL:System.GC.WaitForPendingFinalizers()" 

// It is preferrable to avoid calling GC.Collect() 
// explicitely in order to avoid some performance 
// pitfall. But if you wish to call GC.Collect(), 
// you must do it this way:
//   GC.Collect();
//   GC.WaitForPendingFinalizers();
//   GC.Collect();
// To make sure that finalizer got executed, and 
// object with finalizer got cleaned properly.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Enum Storage should be Int32</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
  NameIs "value__" AND 
  !IsOfType "OPTIONAL:System.Int32" AND
  !IsInFrameworkAssembly

// An enumeration is a value type that defines 
// a set of related named constants. By default, 
// the System.Int32 data type is used to store 
// the constant value. Even though you can change 
// this underlying type, it is not necessary or 
// recommended for most scenarios. Note that there 
// is no significant performance gain in using 
// a data type smaller than Int32. If you cannot 
// use the default data type, you should use one 
// of the CLS-compliant integral types, Byte, 
// Int16, Int32, or Int64, to ensure that all of 
// the enumeration's values are representable in 
// CLS-compliant programming languages.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Do not raise too general exception types</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  // The following exception types are too general 
  // to provide sufficient information to the user:
  ( ( DepthOfCreateA "OPTIONAL:System.Exception" == 1 OR 
      DepthOfCreateA "OPTIONAL:System.ApplicationException" == 1 OR 
      DepthOfCreateA "OPTIONAL:System.SystemException" == 1 )
    // Test for non-constructor, else this rule 
    // would warn on ctor of classes that derive 
    // from these exception types.
    AND !IsConstructor )
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Do not raise reserved exception types</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  // The following exception types are reserved 
  // and should be thrown only by the Common Language Runtime:
  ( DepthOfCreateA "OPTIONAL:System.ExecutionEngineException" == 1 OR 
    DepthOfCreateA "OPTIONAL:System.IndexOutOfRangeException" == 1 OR 
    DepthOfCreateA "OPTIONAL:System.NullReferenceException" == 1 OR
    DepthOfCreateA "OPTIONAL:System.OutOfMemoryException" == 1 OR
    DepthOfCreateA "OPTIONAL:System.StackOverflowException" == 1 OR 
    DepthOfCreateA "OPTIONAL:System.InvalidProgramException" == 1 OR 
    DepthOfCreateA "OPTIONAL:System.AccessViolationException" == 1 OR
    DepthOfCreateA "OPTIONAL:System.CannotUnloadAppDomainException" == 1 OR
    DepthOfCreateA "OPTIONAL:System.BadImageFormatException" == 1 OR 
    DepthOfCreateA "OPTIONAL:System.DataMisalignedException" == 1 )
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use integral or string argument for indexers</Name>
SELECT METHODS WHERE 
IsIndexerGetter AND 
 !( NameIs "get_Item(String)" OR 
    NameLike "get_Item\(Int" OR 
    NameLike "get_Item\(Byte" OR
    NameLike "get_Item\(SByte" )

// Indexers, that is, indexed properties, 
// should use integer or string types for the index. 
// These types are typically used for indexing 
// data structures and increase the usability of 
// the library. Use of the Object type should be 
// restricted to those cases where the specific 
// integer or string type cannot be specified at 
// design time. If the design requires other 
// types for the index, reconsider whether the 
// type represents a logical data store. If it 
// does not represent a logical data store, 
// use a method.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Uri fields should be of type System.Uri</Name>
WARN IF Count > 0 IN SELECT FIELDS WHERE 
  (NameLike "Uri$" OR NameLike "Url$") AND !IsOfType "OPTIONAL:System.Uri"

// A field which name end with 'Uri' is deemed 
// as representing a uri. Such field should be of 
// type System.Uri.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types should not extend System.ApplicationException</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE
  DepthOfDeriveFrom "OPTIONAL:System.ApplicationException" == 1 AND
  !IsInFrameworkAssembly

// For .NET Framework version 1, it was 
// recommended to derive new exceptions from 
// ApplicationException. The recommendation has 
// changed and new exceptions should derive 
// from System.Exception or one of its 
// subclasses in the System namespace.]]></Query>
      </Group>
      <Group Name="System.Collection" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't use .NET 1.x HashTable and ArrayList</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE

  // Prefer using the class 
  // System.Collections.Generic.Dictionary<K,V> over 
  // System.Collections.HashTable.
  CreateA "OPTIONAL:System.Collections.HashTable" OR

  // Prefer using the class 
  // System.Collections.Generic.List<T> over
  // System.Collections.ArrayList.
  CreateA "OPTIONAL:System.Collections.ArrayList"

// You can be forced to use HashTable or ArrayList 
// because you are using third party code that requires 
// working with these classes or because you are 
// coding with .NET 1.x.]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Caution with List.Contains()</Name>
SELECT METHODS WHERE 
  IsDirectlyUsing "OPTIONAL:System.Collections.Generic.List<T>.Contains(T)" OR
  IsDirectlyUsing "OPTIONAL:System.Collections.Generic.IList<T>.Contains(T)" OR
  IsDirectlyUsing "OPTIONAL:System.Collections.ArrayList.Contains(Object)"

// The cost of checking if a list contains an 
// object is proportional to the size of the list 
// (O(N) operation). For large lists and/or frequent 
// calls to Contains(), prefer using the 
// System.Collections.Generic.HashSet<T> class 
// where calls to Contains() takes a constant 
// time (O(0) operation).]]></Query>
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Prefer return collection abstraction instead of implementation</Name>
SELECT METHODS WHERE 
  ReturnTypeIs "OPTIONAL:System.Collections.Generic.List<T>" OR 
  ReturnTypeIs "OPTIONAL:System.Collections.Generic.HashSet<T>" OR
  ReturnTypeIs "OPTIONAL:System.Collections.Generic.Dictionary<TKey,TValue>"

// Most of the time, clients of a method doesn't 
// need to know the exact implementation of the 
// collection returned. It is preferrable to return 
// a collection interface such as IList<T>, 
// ICollection<T> or IEnumerable<T>.]]></Query>
      </Group>
      <Group Name="System.Runtime.InteropServices" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>P/Invokes should be static and not be visible</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE
  !IsInFrameworkAssembly AND
  (HasAttribute "OPTIONAL:System.Runtime.InteropServices.DllImportAttribute") AND
  ( IsPublic OR 
    !IsStatic)

// Methods marked with the DllImportAttribute 
// attribute (or methods defined using the 
// Declare keyword in Visual Basic) use 
// Platform Invocation Services to access unmanaged 
// code. Such methods should not be exposed. Keeping 
// these methods private or internal ensures 
// that your library cannot be used to breach 
// security by allowing callers access to 
// unmanaged APIs they could not call otherwise.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Move P/Invokes to NativeMethods class</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE
  !IsInFrameworkAssembly AND
  HasAttribute "OPTIONAL:System.Runtime.InteropServices.DllImportAttribute" AND
  !FullNameLike "NativeMethods."

// Platform Invocation methods, such as those marked 
// with the System.Runtime.InteropServices.DllImportAttribute 
// attribute, or methods defined by using the Declare 
// keyword in Visual Basic, access unmanaged code. 
// These methods should be in one of the following classes:
//
//   - NativeMethods - This class does not suppress stack 
//     walks for unmanaged code permission. 
//     (System.Security.SuppressUnmanagedCodeSecurityAttribute 
//     must not be applied to this class.) 
//     This class is for methods that can be used 
//     anywhere because a stack walk will be performed.
//
//   - SafeNativeMethods - This class suppresses 
//     stack walks for unmanaged code permission. 
//     (System.Security.SuppressUnmanagedCodeSecurityAttribute 
//     is applied to this class.) 
//     This class is for methods that are safe 
//     for anyone to call. Callers of these methods 
//     are not required to do a full security review 
//     to ensure that the usage is secure because 
//     the methods are harmless for any caller.
//
//   - UnsafeNativeMethods - This class suppresses 
//     stack walks for unmanaged code permission. 
//     (System.Security.SuppressUnmanagedCodeSecurityAttribute 
//     is applied to this class.) This class is for 
//     methods that are potentially dangerous. Any 
//     caller of these methods must do a full security 
//     review to ensure that the usage is secure because 
//     no stack walk will be performed.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>NativeMethods class should be static and internal</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE
  !IsInFrameworkAssembly AND
  ( NameIs "NativeMethods" OR
    NameIs "SafeNativeMethods" OR
    NameIs "UnsafeNativeMethods") AND
  (IsPublic OR
   !IsStatic)

// Native Methods' classes are declared as internal 
// (Friend, in Visual Basic) and static.
]]></Query>
      </Group>
      <Group Name="System.Threading" Active="True" ShownInReport="False">
        <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method non-synchronized that read mutable states</Name>
SELECT METHODS WHERE 
 (ReadsMutableObjectState OR ReadsMutableTypeState) AND 
 !IsDirectlyUsing "OPTIONAL:System.Threading.Monitor" AND 
 !IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock"

// Mutable object states are instance fields that 
// can be modifed throught the lifetime of the object.
// Mutable type states are static fields that can be 
// modifed throught the lifetime of the program.
// This query lists methods that read mutable state 
// without synchronizing access. In the case of 
// multi-threaded program, doing so can lead to 
// state corruption.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't create threads explicitely</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  CreateA "OPTIONAL:System.Threading.Thread"

// Prefer using the thread pool instead of 
// creating manually your own thread.
// Threads are costly objects. 
// They take approximately 200,000 cycles to 
// create and about 100,000 cycles to destroy.  
// By default they reserve 1 megabyte of virtual 
// memory for its stack and use 2,000-8,000 
// cycles for each context switch.
// As a consequence, it is preferrable to let 
// the thread pool recycle threads.

// Creating custom thread can also be the 
// sign of flawed design, where tasks and 
// threads have affinity. It is preferrable 
// to code tasks that can be ran on any thread.]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't use Thread.Sleep()</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE IsDirectlyUsing  "OPTIONAL:System.Threading.Thread.Sleep(Int32)"

// Usage of Thread.Sleep() is a sign of 
// flawed design. More information on this here:
// http://msmvps.com/blogs/peterritchie/archive/2007/04/26/thread-sleep-is-a-sign-of-a-poorly-designed-program.aspx
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't use Thread.Abort()</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
  IsDirectlyUsing  "OPTIONAL:System.Threading.Thread.Abort()" OR
  IsDirectlyUsing  "OPTIONAL:System.Threading.Thread.Abort(Object)" 

// Usage of Thread.Abort() is dangerous.
// More information on this here:
// http://www.interact-sw.co.uk/iangblog/2004/11/12/cancellation]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Monitor Enter/Exit must be both called within the same method</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE
 IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Enter(Object)" AND
 !IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Exit(Object)" ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Monitor TryEnter/Exit must be both called within the same method</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE
 ( IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Enter(Object)" OR
   IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,Int32)" OR
   IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,TimeSpan)") AND
 !IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.Exit(Object)" ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>ReaderWriterLock AcquireReaderLock/ReleaseLock must be both called within the same method</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE
  ( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)" OR
    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)" OR
    IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,TimeSpan)") 
AND
 !( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseReaderLock()" OR 
    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseLock()") ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>ReaderWriterLock AcquireWriterLock/ReleaseLock must be both called within the same method</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE
  ( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)" OR
    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)" OR
    IsDirectlyUsing "OPTIONAL:System.Threading.Monitor.TryEnter(Object,TimeSpan)") 
AND
 !( IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseWriterLock()" OR 
    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock.ReleaseLock()") ]]></Query>
      </Group>
      <Group Name="System.Xml" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method should not return concrete XmlNode</Name>
WARN IF Count > 0 IN SELECT METHODS WHERE 
( ReturnTypeIs "OPTIONAL:System.Xml.XmlDocument" OR 
  ReturnTypeIs "OPTIONAL:System.Xml.XmlAttribute" OR 
  ReturnTypeIs "OPTIONAL:System.Xml.XmlDocumentFragment" OR 
  ReturnTypeIs "OPTIONAL:System.Xml.XmlEntity" OR 
  ReturnTypeIs "OPTIONAL:System.Xml.XmlLinkedNode" OR 
  ReturnTypeIs "OPTIONAL:System.Xml.XmlNotation" OR
  ReturnTypeIs "OPTIONAL:System.Xml.XmlNode" )

// The class System.Xml.XmlNode implements the interface 
// System.Xml.Xpath.IXPathNavigable. It is preferrable 
// to return this interface instead of a concrete class.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types should not extend System.Xml.XmlDocument</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE DepthOfDeriveFrom "OPTIONAL:System.Xml.XmlDocument" == 1

// Do not create a subclass of XmlDocument if you want 
// to create an XML view of an underlying object 
// model or data source.]]></Query>
      </Group>
      <Group Name="System.Globalization" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Float and Date Parsing must be culture aware</Name>
WARN IF Count > 0 IN SELECT METHODS 
  FROM TYPES "OPTIONAL:System.DateTime", 
             "OPTIONAL:System.Single", 
             "OPTIONAL:System.Double",
             "OPTIONAL:System.Decimal"
  // The 'NameLike' CQL clause operates on the signature
  // "methodName(type1,type2...typeN)"
  WHERE (NameLike "Parse\(" OR NameLike "ToString\(") AND
        !NameLike "IFormatProvider"]]></Query>
      </Group>
    </Group>
    <Group Name="Statistics" Active="False" ShownInReport="False">
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (TypeRank)</Name>
SELECT TOP 50 TYPES ORDER BY TypeRank DESC

// TypeRank values are computed by applying 
// the Google PageRank  algorithm on the 
// graph of types' dependencies. Types with 
// high Rank are the most used ones.
// See the definition of the TypeRank metric here: 
// http://www.ndepend.com/Metrics.aspx#TypeRank]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (MethodRank)</Name>
SELECT TOP 50 METHODS ORDER BY MethodRank DESC

// MethodRank values are computed by applying 
// the Google PageRank  algorithm on the graph of 
// methods' dependencies. Methods with high Rank 
// are the most used ones. See the definition of 
// the MethodRank metric here:
// http://www.ndepend.com/Metrics.aspx#MethodRank]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used namespaces (NamespaceCa)</Name>
SELECT TOP 50 NAMESPACES ORDER BY NamespaceCa DESC

// The Afferent Coupling for a particular namespace 
// is the number of namespaces that depends directly 
// on it. Namespaces with high Ca are the most 
// used ones. 
// See the definition of the NamespaceCa metric here:
// http://www.ndepend.com/Metrics.aspx#NamespaceCa]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types  (TypeCa)</Name>
SELECT TOP 50 TYPES ORDER BY TypeCa DESC

// The Afferent Coupling for a particular type 
// is the number of types that depends directly 
// on it. Types with high Ca are the most used ones.
// See the definition of the TypeCa metric here:
// http://www.ndepend.com/Metrics.aspx#TypeCa]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (MethodCa)</Name>
SELECT TOP 50 METHODS ORDER BY MethodCa DESC

// The Afferent Coupling for a particular method 
// is the number of methods that depends directly 
// on it. Methods with high Ca are the most used ones
// See the definition of the MethodCa metric here:
// http://www.ndepend.com/Metrics.aspx#MethodCa]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces that use many other namespaces (NamespaceCe)</Name>
SELECT TOP 50 NAMESPACES ORDER BY NamespaceCe DESC

// The Efferent Coupling for a particular namespace 
// is the number of namespaces it directly depends on.
// Namespaces declared in Framework assemblies are 
// taken account.
// See the definition of the NamespaceCe metric here:
// http://www.ndepend.com/Metrics.aspx#NamespaceCe]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that use many other types (TypeCe)</Name>
SELECT TOP 50 TYPES ORDER BY TypeCe DESC

// The Efferent Coupling for a particular type
// is the number of types it directly depends on.
// Types declared in Framework assemblies are 
// taken account.
// See the definition of the TypeCe metric here:
// http://www.ndepend.com/Metrics.aspx#TypeCe]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that use many other methods (MethodCe)</Name>
SELECT TOP 50 METHODS ORDER BY MethodCe DESC

// The Efferent Coupling for a particular method 
// is the number of methods it directly depends on.
// Methods declared in Framework assemblies are 
// taken account.
// See the definition of the MethodCe metric here http://www.ndepend.com/Metrics.aspx#MethodCe]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level assemblies (AssemblyLevel)</Name>
SELECT ASSEMBLIES ORDER BY AssemblyLevel DESC

// Classify assemblies by their Level values.
// See the definition of the AssemblyLevel metric here:
// http://www.ndepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level namespaces (NamespaceLevel)</Name>
SELECT NAMESPACES ORDER BY NamespaceLevel DESC

// Classify namespaces by their Level values.
// See the definition of the NamespaceLevel metric here:
// http://www.ndepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level types (TypeLevel)</Name>
SELECT TYPES ORDER BY TypeLevel DESC

// Classify types by their Level values.
// See the definition of the TypeLevel metric here:
// http://www.ndepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level methods (MethodLevel)</Name>
SELECT METHODS ORDER BY MethodLevel DESC

// Classify methods by their Level values.
// See the definition of the MethodLevel metric here:
// http://www.ndepend.com/Metrics.aspx#Level]]></Query>
    </Group>
    <Group Name="Samples of Custom rules" Active="False" ShownInReport="False">
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the assembly Asm1 is not using the assembly Asm2</Name>

WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  IsDirectlyUsing "OPTIONAL:ASSEMBLY:Asm2" AND
  NameIs "Asm1"

// The OPTIONAL: prefix is just use to avoid an 
//error because there is currently no assembly named Asm2.
]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the namespace N1.N2 is not using the namespace N3.N4.N5</Name>

WARN IF Count > 0 IN SELECT NAMESPACES WHERE 
  IsDirectlyUsing "OPTIONAL:ASSEMBLY:N3.N4.N5" AND
  NameIs "N1.N2"

// The OPTIONAL: prefix is just use to avoid an 
// error because there is currently no namespace named N3.N4.N5.
]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the assembly Asm1 is only using the assemblies Asm2, Asm3 or mscorlib</Name>

WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  ( !IsDirectlyUsing "OPTIONAL:ASSEMBLY:Asm2" OR
    !IsDirectlyUsing "OPTIONAL:ASSEMBLY:Asm3" OR
    !IsDirectlyUsing "ASSEMBLY:mscorlib" OR
    AsmCe != 3) // Must not be used more than 3 assemblies 
                // AsmCe = Efferent Coupling for assembly
AND 
  NameIs "Asm1"
  // The OPTIONAL: prefix is just use to avoid an 
  // error because there is currently no assembly 
  // named Asm2 or Asm3.
]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the namespace N1.N2 is only using the namespaces N3.N4, N5 or System</Name>

WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  ( !IsDirectlyUsing "OPTIONAL:NAMESPACE:N3.N4" OR
    !IsDirectlyUsing "OPTIONAL:NAMESPACE:N5" OR
    !IsDirectlyUsing "NAMESPACE:System" OR
    AsmCe != 3) // Must not be used more than 3 assemblies 
                // AsmCe = Efferent Coupling for assembly
AND 
  NameIs "Asm1"
  // The OPTIONAL: prefix is just use to avoid an
  // error because there is currently no namespace 
  // named N3.N4 or N5.
]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that AsmDrawing is the only assembly that is using System.Drawing</Name>
WARN IF Count> 0 IN SELECT ASSEMBLIES WHERE 
  IsDirectlyUsing "OPTIONAL:ASSEMBLY:System.Drawing" AND
  !NameIs "AsmDrawing"

// The OPTIONAL: prefix is just use to avoid 
// an error because System.Drawing might not 
// be currently referenced.
]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that only 3 assemblies are using System.Drawing</Name>
WARN IF Count > 3 IN SELECT ASSEMBLIES WHERE 
  IsDirectlyUsing "OPTIONAL:ASSEMBLY:System.Drawing"

// The OPTIONAL: prefix is just use to avoid an 
// error because System.Drawing might not be 
// currently referenced.
]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all methods that call Foo.Fct1() also call Foo.Fct2(Int32)</Name>

WARN IF Count > 0 IN SELECT METHODS WHERE 
  IsDirectlyUsing "OPTIONAL:Foo.Fct1()" AND
  !IsDirectlyUsing "OPTIONAL:Foo.Fct2(Int32)"
  // The OPTIONAL: prefix is just use to avoid an error 
  // because there is currently no methods named 
  // Foo.Fct1() or Foo.Fct2(Int32)]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that derive from Foo, also implement IFoo</Name>

WARN IF Count > 0 IN SELECT TYPES WHERE 
  DeriveFrom "OPTIONAL:TYPE:Foo" AND
  !Implement "OPTIONAL:TYPE:IFoo"
  // The OPTIONAL: prefix is just use to avoid an 
  // error because there is currently no class named 
  // Foo and no interface named IFoo]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that has the attribute FooAttribute are declared in the namespace N1.N2</Name>

WARN IF Count > 0 IN SELECT TYPES 
  OUT OF NAMESPACES "OPTIONAL:N1.N2" 
  WHERE 
    HasAttribute "OPTIONAL:FooAttribute"

  // The OPTIONAL: prefix is just use to avoid an 
  // error because there is currently no attribute 
  // class named FooAttribute and no namespace named N1.N2]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all synchronization objects are only used from the namespaces under MyNamespace.Sync</Name>

WARN IF Count > 0 IN SELECT NAMESPACES 
  WHERE 
    IsDirectlyUsing "OPTIONAL:System.Threading.Monitor" OR
    IsDirectlyUsing "OPTIONAL:System.Threading.ReaderWriterLock" OR
    IsDirectlyUsing "OPTIONAL:System.Threading.Mutex" OR
    IsDirectlyUsing "OPTIONAL:System.Threading.EventWaitHandle" OR
    IsDirectlyUsing "OPTIONAL:System.Threading.Semaphore" OR
    IsDirectlyUsing "OPTIONAL:System.Threading.Interlocked" 
  AND !NameLike "^MyNamespace.Sync"

  // The OPTIONAL: prefix is just use to avoid an 
  // error because there some code elemnts might 
  // not currently exists.]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the graph of namespaces dependencies of the assembly Asm is acyclic</Name>
WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  NameIs "OPTIONAL:Asm" AND
  ContainsNamespaceDependencyCycle

  // The OPTIONAL: prefix is just use to avoid 
  // an error because there is currently no assembly 
  // named Asm]]></Query>
      <Group Name="Check Coverage on particular Code Elements" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the assembly Asm is 100% covered by tests</Name>
WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE 
  NameIs "Asm" AND 
  PercentageCoverage < 100


// To run this rule properly coverage data 
// must be gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the namespace N1.N2 is 100% covered by tests</Name>
WARN IF Count > 0 IN SELECT NAMESPACES WHERE 
  NameIs "N1.N2" AND 
  PercentageCoverage < 100


// To run this rule properly coverage data 
// must be gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the class Namespace.Foo is 100% covered by tests</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  FullNameIs "Namespace.Foo" AND 
  PercentageCoverage < 100


// To run this rule properly coverage data 
// must be gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the class Namespace.Foo.Method(Int32) is 100% covered by tests</Name>
WARN IF Count > 0 IN SELECT TYPES WHERE 
  FullNameIs "Namespace.Foo.Method(Int32)" AND 
  PercentageCoverage < 100


// To run this rule properly coverage data 
// must be gathered from NCover™ or Visual Studio™ Coverage.
// This can be done throught the menu: 
//   NDepend -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.ndepend.com/Coverage.aspx

]]></Query>
      </Group>
      <Group Name="Custom Naming Conventions" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that derive from Foo, has a name that ends up with Foo</Name>

WARN IF Count > 0 IN SELECT TYPES WHERE 
  DeriveFrom "OPTIONAL:TYPE:Foo" AND
  !NameLike "Foo$"
  // The OPTIONAL: prefix is just use to avoid 
  // an error because there is currently no 
  // class named Foo]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all namespaces begins with CompanyName.ProductName</Name>
WARN IF Count > 0 IN SELECT NAMESPACES WHERE 
  !NameLike "^CompanyName.ProductName"
  AND !IsInFrameworkAssembly ]]></Query>
      </Group>
    </Group>
  </Queries>
</NDepend>